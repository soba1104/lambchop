#!/usr/bin/env ruby

require 'erb'

class VMGen
  private

  def indent_stmt(stmt, indent)
    stmt.lines.map{|l| (' ' * indent) + l}.join()
  end

  def fetch_rex_stmt(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  if (IS_REX(__v)) {
    #{ipreg}++;
    #{dst} = __v;
  }
}
    EOS
  end

  def fetch_opcode_stmt(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  #{ipreg}++;
  #{dst} = __v;
}
    EOS
  end

  TEMPLATE = <<-EOS
#include "lambchop.h"

#include <stdint.h>
#include <stdlib.h>

#include <assert.h>

#define ERR(...) lambchop_err(logger, __VA_ARGS__)
#define INFO(...) lambchop_info(logger, __VA_ARGS__)
#define DEBUG(...) lambchop_debug(logger, __VA_ARGS__)

#define IS_REX(v) (((v) & 0xf0) == 0x40)

int vm_main(void *func, uint64_t stacksize, lambchop_logger *logger)
{
  uint64_t rip;
  uint64_t rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi;
  uint64_t r8, r9, r10, r11, r12, r13, r14, r15;
  uint8_t opcode, rex, modrm;
  void *stack = malloc(stacksize);

  assert(stack); // TODO: return error
  rip = (uint64_t)func;
  rbp = (uint64_t)stack;
  rsp = (uint64_t)stack;

  while (true) {
<% indent = 4 -%>
<%= fetch_rex_stmt('rip', 'rex', indent) -%>
<%= fetch_opcode_stmt('rip', 'opcode', indent) -%>
    switch(opcode) {
      default:
        DEBUG("unsupported opcode: 0x%x\\n", opcode);
        assert(false);
    }
  }

  if (stack) {
    free(stack);
  }

  return 0;
}
  EOS

  public
  def generate()
    ERB.new(TEMPLATE, 0, '%-').result(binding)
  end
end

puts VMGen.new.generate()
