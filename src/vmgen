#!/usr/bin/env ruby

require 'erb'

class Instruction
  private
  REGNAMES = [
    'RAX',
    'RCX',
    'RDX',
    'RBX',
    'RSP',
    'RBP',
    'RSI',
    'RDI',
    'R8',
    'R9',
    'R10',
    'R11',
    'R12',
    'R13',
    'R14',
    'R15',
  ]

  protected
  def regname(id)
    REGNAMES[id]
  end
end

class Instruction0x50To0x57 < Instruction
  public
  def gen_stmt(ipreg)
    (0..7).map{|i|
      stmt = <<-EOS
case 0x5#{i}:
{
  DEBUG("PUSH #{regname(i)}\\n");
  #{ipreg}++;
  break;
}
      EOS
      stmt.chomp()
    }.join("\n")
  end
end

class VMGen
  private

  def indent_stmt(stmt, indent)
    stmt.lines.map{|l| (' ' * indent) + l}.join()
  end

  def gen_rex_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  if (IS_REX(__v)) {
    #{ipreg}++;
    #{dst} = __v;
  }
}
    EOS
  end

  def gen_opcode_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  #{ipreg}++;
  #{dst} = __v;
}
    EOS
  end

  def gen_instruction(inst, ipreg, indent)
    indent_stmt(inst.gen_stmt(ipreg), indent)
  end

  TEMPLATE = <<-EOS
#include "lambchop.h"

#include <stdint.h>
#include <stdlib.h>

#include <assert.h>

#define ERR(...) lambchop_err(logger, __VA_ARGS__)
#define INFO(...) lambchop_info(logger, __VA_ARGS__)
#define DEBUG(...) lambchop_debug(logger, __VA_ARGS__)

#define IS_REX(v) (((v) & 0xf0) == 0x40)

int vm_main(void *func, uint64_t stacksize, lambchop_logger *logger)
{
  uint64_t rip;
  uint64_t rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi;
  uint64_t r8, r9, r10, r11, r12, r13, r14, r15;
  uint8_t opcode, rex, modrm;
  void *stack = malloc(stacksize);

  assert(stack); // TODO: return error
  rip = (uint64_t)func;
  rbp = (uint64_t)stack;
  rsp = (uint64_t)stack;

  while (true) {
<% indent = 4 -%>
<%= gen_rex_fetch('rip', 'rex', indent) -%>
<%= gen_opcode_fetch('rip', 'opcode', indent) -%>
    switch(opcode) {
<% instructions.each do |inst| -%>
<%= gen_instruction(inst, 'rip', indent) -%>
<% end -%>
      default:
        DEBUG("unsupported opcode: 0x%x\\n", opcode);
        assert(false);
    }
  }

  if (stack) {
    free(stack);
  }

  return 0;
}
  EOS

  public
  def generate()
    instructions = [
      Instruction0x50To0x57.new()
    ]
    ERB.new(TEMPLATE, 0, '%-').result(binding)
  end
end

puts VMGen.new.generate()
