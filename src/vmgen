#!/usr/bin/env ruby

require 'erb'

REGNAMES = [
  'rax',
  'rcx',
  'rdx',
  'rbx',
  'rsp',
  'rbp',
  'rsi',
  'rdi',
  'r8',
  'r9',
  'r10',
  'r11',
  'r12',
  'r13',
  'r14',
  'r15',
]

module CodeGenerator
  def indent_stmt(stmt, indent)
    stmt.lines.map{|l| (' ' * indent) + l}.join()
  end
end

class Instruction
  include CodeGenerator

  protected
  def self.spec_opcodes(opcodes)
    @spec_opcodes = opcodes
  end

  def self.spec_operands(operands)
    @spec_operands = operands
  end

  def initialize()
    @opcodes = self.class.instance_variable_get('@spec_opcodes')
    raise("#{self.class}: opcodes not given") unless @opcodes
    @operands = self.class.instance_variable_get('@spec_operands')
    raise("#{self.class}: operands not given") unless @operands
  end

  def gen(body)
    ERB.new(<<-EOS, 0, '%-').result(binding)
<% @opcodes.each do |opcode| -%>
case <%= opcode %>:
<% end -%>
{
<% @operands.each do |operand| -%>
<%= indent_stmt(gen_operand(operand), 2) -%>
<% end -%>
<%= indent_stmt(body.chomp, 2) %>
  break;
}
    EOS
  end

  private
  def gen_operand(operand)
    ""
  end

  def fetch_modrm(ipreg, dst, indent)
    indent_stmt("#{dst} = FETCH_MODRM(#{ipreg});", indent)
  end
end

class Instruction0x50To0x57 < Instruction
  spec_opcodes (0..7).map{|i| "0x5#{i}"}
  spec_operands [:opcode_reg]

  public
  def gen_stmt(ipreg)
    gen(<<-EOS)
uint8_t reg = opcode & 0x07;
DEBUG("push %s\\n", regnames[reg]);
*((uint64_t*)rsp) = *regs[reg];
rsp -= sizeof(uint64_t);
    EOS
  end
end

class Instruction0x83 < Instruction
  spec_opcodes ['0x83']
  spec_operands [:modrm_reg, :modrm_modrm, :imm_s8]

  public
  def gen_stmt(ipreg)
    gen(<<-EOS)
uint8_t modrm = FETCH_MODRM(#{ipreg});
int8_t imm = FETCH_IMM_S8(#{ipreg});
uint8_t op_ext = MODRM_OP_EXT(modrm);
uint8_t mod = MODRM_MOD(modrm);
uint8_t rm = MODRM_RM(modrm);
uint8_t target = IS_REX_R(rex) ? (REX_REG_BIT | rm) : rm;
assert(mod == MODRM_MOD_REG);
switch(op_ext) {
case 0x05: // SUB
{
  DEBUG("sub 0x%x %s\\n", imm, regnames[target]);
  *regs[target] -= imm;
  break;
}
default:
  DEBUG("opcode 0x83: unsupported op_ext 0x%x\\n", op_ext);
  assert(false);
}
    EOS
  end
end

class Instruction0x89 < Instruction
  spec_opcodes ['0x89']
  spec_operands [:modrm_reg, :modrm_modrm]

  public
  def gen_stmt(ipreg)
    gen(<<-EOS)
uint8_t modrm = FETCH_MODRM(#{ipreg});
uint8_t mod = MODRM_MOD(modrm);
uint8_t rm = MODRM_RM(modrm);
uint8_t src = MODRM_REG(modrm);
uint8_t dst = IS_REX_R(rex) ? (REX_REG_BIT | rm) : rm;
assert(mod == MODRM_MOD_REG);
DEBUG("mov %s %s\\n", regnames[src], regnames[dst]);
*regs[dst] = *regs[src];
    EOS
  end
end

class VMGen
  include CodeGenerator

  private

  def gen_rex_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  if (IS_REX(__v)) {
    #{ipreg}++;
    #{dst} = __v;
  }
}
    EOS
  end

  def gen_opcode_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  #{ipreg}++;
  #{dst} = __v;
}
    EOS
  end

  def gen_instruction(inst, ipreg, indent)
    indent_stmt(inst.gen_stmt(ipreg), indent)
  end

  TEMPLATE = <<-EOS
#include "lambchop.h"

#include <stdint.h>
#include <stdlib.h>

#include <assert.h>

#define ERR(...) lambchop_err(logger, __VA_ARGS__)
#define INFO(...) lambchop_info(logger, __VA_ARGS__)
#define DEBUG(...) lambchop_debug(logger, __VA_ARGS__)

#define REGISTER_RAX 0x00
#define REGISTER_RCX 0x01
#define REGISTER_RDX 0x02
#define REGISTER_RBX 0x03
#define REGISTER_RSP 0x04
#define REGISTER_RBP 0x05
#define REGISTER_RSI 0x06
#define REGISTER_RDI 0x07
#define REGISTER_R8  (REX_REG_BIT & 0x00)
#define REGISTER_R9  (REX_REG_BIT & 0x01)
#define REGISTER_R10 (REX_REG_BIT & 0x02)
#define REGISTER_R11 (REX_REG_BIT & 0x03)
#define REGISTER_R12 (REX_REG_BIT & 0x04)
#define REGISTER_R13 (REX_REG_BIT & 0x05)
#define REGISTER_R14 (REX_REG_BIT & 0x06)
#define REGISTER_R15 (REX_REG_BIT & 0x07)

#define IS_REX(v) (((v) & 0xf0) == 0x40)
#define IS_REX_W(rex) ((rex) & 0x08)
#define IS_REX_R(rex) ((rex) & 0x04)
#define IS_REX_X(rex) ((rex) & 0x02)
#define IS_REX_B(rex) ((rex) & 0x01)
#define REX_REG_BIT 0x10

#define FETCH_MODRM(ipreg) (*((uint8_t*)(ipreg++)))
#define MODRM_REG(modrm) (((modrm) & 0x38) >> 3)
#define MODRM_MOD(modrm) (((modrm) & 0xc0) >> 6)
#define MODRM_RM(modrm) ((modrm) & 0x07)
#define MODRM_OP_EXT(modrm) (((modrm) & 0x38) >> 3)
#define MODRM_MOD_MEM_DISP0 0
#define MODRM_MOD_MEM_DISP8 1
#define MODRM_MOD_MEM_DISP32 2
#define MODRM_MOD_REG 3

#define FETCH_IMM_S8(ipreg) (*((int8_t*)(ipreg++)))

static const char *regnames[] = {
  "rax",
  "rcx",
  "rdx",
  "rbx",
  "rsp",
  "rbp",
  "rsi",
  "rdi",
  "r8",
  "r9",
  "r10",
  "r11",
  "r12",
  "r13",
  "r14",
  "r15"
};

int lambchop_vm_main(void *func, uint64_t stacksize, lambchop_logger *logger)
{
  uint64_t rip, *regs[16];
  uint8_t opcode, rex, modrm;
  void *stack = malloc(stacksize);
<% REGNAMES.each do |r| -%>
  uint64_t <%= r %>;
<% end -%>
<% REGNAMES.each_with_index do |r, i| -%>
  regs[<%= i %>] = &<%= r %>;
<% end -%>

  assert(stack); // TODO: return error
  rip = (uint64_t)func;
  rbp = ((uint64_t)stack) + (stacksize - sizeof(uint64_t));
  rsp = ((uint64_t)stack) + (stacksize - sizeof(uint64_t));

  while (true) {
<% indent = 4 -%>
<%= gen_rex_fetch('rip', 'rex', indent) -%>
<%= gen_opcode_fetch('rip', 'opcode', indent) -%>
    switch(opcode) {
<% instructions.each do |inst| -%>
<%= gen_instruction(inst, 'rip', indent) -%>
<% end -%>
    default:
      DEBUG("unsupported opcode: 0x%x\\n", opcode);
      assert(false);
    }
  }

  if (stack) {
    free(stack);
  }

  return 0;
}
  EOS

  public
  def generate()
    instructions = [
      Instruction0x50To0x57.new(),
      Instruction0x83.new(),
      Instruction0x89.new(),
    ]
    ERB.new(TEMPLATE, 0, '%-').result(binding)
  end
end

puts VMGen.new.generate()
