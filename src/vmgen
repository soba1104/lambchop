#!/usr/bin/env ruby

require 'erb'

class Instruction
  private
  REGNAMES = [
    'RAX',
    'RCX',
    'RDX',
    'RBX',
    'RSP',
    'RBP',
    'RSI',
    'RDI',
    'R8',
    'R9',
    'R10',
    'R11',
    'R12',
    'R13',
    'R14',
    'R15',
  ]

  protected
  def regname(id)
    REGNAMES[id]
  end
end

class Instruction0x50To0x57 < Instruction
  public
  def gen_stmt(ipreg)
    (0..7).map{|i|
      stmt = <<-EOS
case 0x5#{i}:
{
  DEBUG("PUSH #{regname(i)}\\n");
  #{ipreg}++;
  break;
}
      EOS
    }.join()
  end
end

class Instruction0x83 < Instruction
  public
  def gen_stmt(ipreg)
    stmt = <<-EOS
case 0x83:
{
  uint8_t modrm = FETCH_MODRM(#{ipreg});
  char imm = FETCH_IMM_SB(#{ipreg});
  uint8_t op_ext = MODRM_OP_EXT(modrm);
  uint8_t mod = MODRM_MOD(modrm);
  uint8_t rm = MODRM_RM(modrm);
  uint8_t target = IS_REX_R(rex) ? (REX_REG_BIT | rm) : rm;
  assert(mod == MODRM_MOD_REG);
  switch(op_ext) {
  case 0x05: // SUB
  {
    DEBUG("SUB 0x%x %s\\n", imm, regnames[target]);
    break;
  }
  default:
    DEBUG("opcode 0x83: unsupported op_ext 0x%x\\n", op_ext);
    assert(false);
  }
}
    EOS
  end
end

class Instruction0x89 < Instruction
  public
  def gen_stmt(ipreg)
    stmt = <<-EOS
case 0x89:
{
  uint8_t modrm = FETCH_MODRM(#{ipreg});
  uint8_t mod = MODRM_MOD(modrm);
  uint8_t rm = MODRM_RM(modrm);
  uint8_t src = MODRM_REG(modrm);
  uint8_t dst = IS_REX_R(rex) ? (REX_REG_BIT | rm) : rm;
  assert(mod == MODRM_MOD_REG);
  DEBUG("MOV %s %s\\n", regnames[src], regnames[dst]);
  break;
}
    EOS
  end
end

class VMGen
  private

  def indent_stmt(stmt, indent)
    stmt.lines.map{|l| (' ' * indent) + l}.join()
  end

  def gen_rex_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  if (IS_REX(__v)) {
    #{ipreg}++;
    #{dst} = __v;
  }
}
    EOS
  end

  def gen_opcode_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  #{ipreg}++;
  #{dst} = __v;
}
    EOS
  end

  def gen_instruction(inst, ipreg, indent)
    indent_stmt(inst.gen_stmt(ipreg), indent)
  end

  TEMPLATE = <<-EOS
#include "lambchop.h"

#include <stdint.h>
#include <stdlib.h>

#include <assert.h>

#define ERR(...) lambchop_err(logger, __VA_ARGS__)
#define INFO(...) lambchop_info(logger, __VA_ARGS__)
#define DEBUG(...) lambchop_debug(logger, __VA_ARGS__)

#define IS_REX(v) (((v) & 0xf0) == 0x40)
#define IS_REX_W(rex) ((rex) & 0x08)
#define IS_REX_R(rex) ((rex) & 0x04)
#define IS_REX_X(rex) ((rex) & 0x02)
#define IS_REX_B(rex) ((rex) & 0x01)
#define REX_REG_BIT 0x10

#define FETCH_MODRM(ipreg) (*((uint8_t*)(ipreg++)))
#define MODRM_REG(modrm) (((modrm) & 0x38) >> 3)
#define MODRM_MOD(modrm) (((modrm) & 0xc0) >> 6)
#define MODRM_RM(modrm) ((modrm) & 0x07)
#define MODRM_OP_EXT(modrm) (((modrm) & 0x38) >> 3)
#define MODRM_MOD_MEM_DISP0 0
#define MODRM_MOD_MEM_DISP8 1
#define MODRM_MOD_MEM_DISP32 2
#define MODRM_MOD_REG 3

#define FETCH_IMM_SB(ipreg) (*((int8_t*)(ipreg++)))

static const char *regnames[] = {
  "RAX",
  "RCX",
  "RDX",
  "RBX",
  "RSP",
  "RBP",
  "RSI",
  "RDI",
  "R8",
  "R9",
  "R10",
  "R11",
  "R12",
  "R13",
  "R14",
  "R15"
};

int vm_main(void *func, uint64_t stacksize, lambchop_logger *logger)
{
  uint64_t rip;
  uint64_t rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi;
  uint64_t r8, r9, r10, r11, r12, r13, r14, r15;
  uint8_t opcode, rex, modrm;
  void *stack = malloc(stacksize);

  assert(stack); // TODO: return error
  rip = (uint64_t)func;
  rbp = (uint64_t)stack;
  rsp = (uint64_t)stack;

  while (true) {
<% indent = 4 -%>
<%= gen_rex_fetch('rip', 'rex', indent) -%>
<%= gen_opcode_fetch('rip', 'opcode', indent) -%>
    switch(opcode) {
<% instructions.each do |inst| -%>
<%= gen_instruction(inst, 'rip', indent) -%>
<% end -%>
    default:
      DEBUG("unsupported opcode: 0x%x\\n", opcode);
      assert(false);
    }
  }

  if (stack) {
    free(stack);
  }

  return 0;
}
  EOS

  public
  def generate()
    instructions = [
      Instruction0x50To0x57.new(),
      Instruction0x83.new(),
      Instruction0x89.new(),
    ]
    ERB.new(TEMPLATE, 0, '%-').result(binding)
  end
end

puts VMGen.new.generate()
