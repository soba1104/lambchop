#!/usr/bin/env ruby

require 'erb'

module CodeGenerator
  REGNAMES = [
    'rax',
    'rcx',
    'rdx',
    'rbx',
    'rsp',
    'rbp',
    'rsi',
    'rdi',
    'r8',
    'r9',
    'r10',
    'r11',
    'r12',
    'r13',
    'r14',
    'r15',
  ]

  def indent_stmt(stmt, indent)
    stmt.lines.map{|l| (' ' * indent) + l}.join()
  end

  def opcode_var()
    'opcode'
  end

  def operand_var(idx)
    "op#{idx}"
  end

  def rex_var()
    'rex'
  end

  def regs_var()
    'regs'
  end

  def modrm_var()
    'modrm'
  end
end

class Instruction
  extend CodeGenerator
  include CodeGenerator

  public
  def gen(ipreg)
    ERB.new(<<-EOS, 0, '%-').result(binding)
<% @opcodes.each do |opcode| -%>
case <%= opcode %>:
<% end -%>
{
<% if @fetch_modrm -%>
  uint8_t <%= modrm_var() %>;
<% end -%>
<% @operands.each_with_index do |operand, idx| -%>
  <%= gen_operand_declare(operand, idx) %>;
<% end -%>
<% if @fetch_modrm -%>
<%= indent_stmt(gen_modrm_fetch(ipreg), 2) -%>
<% end -%>
<% @operands.each_with_index do |operand, idx| -%>
<%= indent_stmt(gen_operand_init(operand, idx, ipreg), 2) -%>
<% end -%>
<%= indent_stmt(gen_debug(), 2) -%>
<%= indent_stmt(gen_body(ipreg), 2) -%>
  break;
}
    EOS
  end

  protected
  def self.spec_mnemonic(mnemonic)
    @spec_mnemonic = mnemonic
  end

  def self.spec_opcodes(opcodes)
    @spec_opcodes = opcodes
  end

  def self.spec_operands(operands)
    @spec_operands = operands
  end

  def self.spec_body(body)
    @spec_body = body
  end

  def initialize()
    @mnemonic = self.class.instance_variable_get('@spec_mnemonic')
    raise("#{self.class}: mnemonic not given") unless @mnemonic
    @opcodes = self.class.instance_variable_get('@spec_opcodes')
    raise("#{self.class}: opcodes not given") unless @opcodes
    @operands = self.class.instance_variable_get('@spec_operands')
    raise("#{self.class}: operands not given") unless @operands
    @body = self.class.instance_variable_get('@spec_body')
    raise("#{self.class}: body not given") unless @body
    @fetch_modrm = !(@operands & [:modrm_reg, :modrm_modrm]).empty?
  end

  private
  def gen_debug()
    n = @operands.size
    vars = []
    @operands.each_with_index do |operand, idx|
      vars.push(operand_var(idx))
    end
    return <<-EOS
DEBUG("process: #{@mnemonic}#{' 0x%x' * n}\\n"#{vars.empty? ? '' : ', '}#{vars.join(', ')});
    EOS
  end

  def gen_body(ipreg)
    @body
  end

  def gen_operand_declare(operand, idx)
    case operand
    when :opcode_reg, :modrm_reg, :modrm_modrm
      "uint64_t *#{operand_var(idx)}"
    when :modrm_extop
      "uint8_t #{operand_var(idx)}"
    when :imm_s8
      "int8_t #{operand_var(idx)}"
    else
      raise("#{self.class}: unknown operand #{operand}")
    end
  end

  def gen_operand_init(operand, idx, ipreg)
    case operand
    when :opcode_reg
      gen_operand_opcode_reg(idx)
    when :modrm_reg
      gen_operand_modrm_reg(idx)
    when :modrm_modrm
      gen_operand_modrm_modrm(idx, ipreg)
    when :modrm_extop
      gen_operand_modrm_extop(idx)
    when :imm_s8
      gen_operand_imm_s8(idx, ipreg)
    else
      raise("#{self.class}: unknown operand #{operand}")
    end
  end

  def gen_operand_opcode_reg(idx)
    return <<-EOS
#{operand_var(idx)} = regs[#{opcode_var()} & 0x07];
    EOS
  end

  def gen_operand_modrm_reg(idx)
    return <<-EOS
#{operand_var(idx)} = regs[MODRM_REG(#{modrm_var()})];
    EOS
  end

  def gen_operand_modrm_modrm(idx, ipreg)
    return <<-EOS
#{operand_var(idx)} = FETCH_OPERAND_MODRM_MODRM(#{modrm_var()}, #{rex_var()}, #{regs_var()}, #{ipreg});
    EOS
  end

  def gen_operand_modrm_extop(idx)
    return <<-EOS
#{operand_var(idx)} = MODRM_EXTOP(#{modrm_var()});
    EOS
  end

  def gen_operand_imm_s8(idx, ipreg)
    return <<-EOS
#{operand_var(idx)} = FETCH_OPERAND_IMM_S8(#{ipreg});
    EOS
  end

  def gen_modrm_fetch(ipreg)
    return <<-EOS
#{modrm_var()} = FETCH_MODRM(#{ipreg});
    EOS
  end
end

class Instruction0x50To0x57 < Instruction
  spec_mnemonic 'push'
  spec_opcodes (0..7).map{|i| "0x5#{i}"}
  spec_operands [:opcode_reg]
  spec_body <<-EOS
*((uint64_t*)rsp) = *#{operand_var(0)};
rsp -= sizeof(uint64_t);
  EOS
end

class Instruction0x83 < Instruction
  spec_mnemonic 'add/or/adc/sbb/and/sub/xor/cmp'
  spec_opcodes ['0x83']
  spec_operands [:modrm_extop, :modrm_modrm, :imm_s8]
  spec_body <<-EOS
switch(#{operand_var(0)}) {
case 0x05: // SUB
{
  *#{operand_var(1)} -= #{operand_var(2)};
  break;
}
default:
  DEBUG("opcode 0x83: unsupported extop 0x%x\\n", #{operand_var(0)});
  assert(false);
}
  EOS
end

class Instruction0x89 < Instruction
  spec_mnemonic 'mov'
  spec_opcodes ['0x89']
  spec_operands [:modrm_reg, :modrm_modrm]
  spec_body <<-EOS
*#{operand_var(1)} = *#{operand_var(0)};
  EOS
end

class Instruction0x8D < Instruction
  spec_mnemonic 'lea'
  spec_opcodes ['0x8d']
  spec_operands [:modrm_modrm, :modrm_reg]
  spec_body <<-EOS
*#{operand_var(1)} = (uint64_t)(#{operand_var(0)});
  EOS
end

class VMGen
  include CodeGenerator

  private

  def gen_rex_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  if (IS_REX(__v)) {
    #{ipreg}++;
    #{dst} = __v;
  }
}
    EOS
  end

  def gen_opcode_fetch(ipreg, dst, indent)
    indent_stmt(<<-EOS, indent)
{
  uint8_t *__p = (uint8_t*)#{ipreg};
  uint8_t __v = *__p;
  #{ipreg}++;
  #{dst} = __v;
}
    EOS
  end

  def gen_instruction(inst, ipreg, indent)
    indent_stmt(inst.gen(ipreg), indent)
  end

  TEMPLATE = <<-EOS
#include "lambchop.h"

#include <stdint.h>
#include <stdlib.h>

#include <assert.h>

#define ERR(...) lambchop_err(logger, __VA_ARGS__)
#define INFO(...) lambchop_info(logger, __VA_ARGS__)
#define DEBUG(...) lambchop_debug(logger, __VA_ARGS__)

#define REGISTER_RAX 0x00
#define REGISTER_RCX 0x01
#define REGISTER_RDX 0x02
#define REGISTER_RBX 0x03
#define REGISTER_RSP 0x04
#define REGISTER_RBP 0x05
#define REGISTER_RSI 0x06
#define REGISTER_RDI 0x07
#define REGISTER_R8  (REX_REG_BIT & 0x00)
#define REGISTER_R9  (REX_REG_BIT & 0x01)
#define REGISTER_R10 (REX_REG_BIT & 0x02)
#define REGISTER_R11 (REX_REG_BIT & 0x03)
#define REGISTER_R12 (REX_REG_BIT & 0x04)
#define REGISTER_R13 (REX_REG_BIT & 0x05)
#define REGISTER_R14 (REX_REG_BIT & 0x06)
#define REGISTER_R15 (REX_REG_BIT & 0x07)

#define IS_REX(v) (((v) & 0xf0) == 0x40)
#define IS_REX_W(rex) ((rex) & 0x08)
#define IS_REX_R(rex) ((rex) & 0x04)
#define IS_REX_X(rex) ((rex) & 0x02)
#define IS_REX_B(rex) ((rex) & 0x01)
#define REX_REG_BIT 0x10

#define FETCH_MODRM(ipreg) (*((uint8_t*)(ipreg++)))
#define MODRM_REG(modrm) (((modrm) & 0x38) >> 3)
#define MODRM_MOD(modrm) (((modrm) & 0xc0) >> 6)
#define MODRM_RM(modrm) ((modrm) & 0x07)
#define MODRM_EXTOP(modrm) (((modrm) & 0x38) >> 3)
#define MODRM_MOD_MEM_DISP0 0
#define MODRM_MOD_MEM_DISP8 1
#define MODRM_MOD_MEM_DISP32 2
#define MODRM_MOD_REG 3
#define MODRM_RM_SIB 4
#define MODRM_RM_IP 5

uint64_t *fetch_operand_modrm_modrm(uint8_t modrm, uint8_t rex, uint64_t **regs, uint64_t *ipp) {
  uint8_t mod = MODRM_MOD(modrm);
  uint8_t rm = MODRM_RM(modrm);
  uint64_t ip = *ipp, result;
  int64_t disp = 0;

  if (mod == MODRM_MOD_REG) {
    return regs[IS_REX_R(rex) ? (REX_REG_BIT | rm) : rm];
  }
  if (rm == MODRM_RM_SIB) {
    assert(false);
  } else if (rm == MODRM_RM_IP) {
    if (mod == MODRM_MOD_MEM_DISP8) {
      disp = *((int8_t*)(ip));
      ip += 1;
    } else {
      disp = *((int32_t*)(ip));
      ip += 4;
    }
    result = ip + disp;
  } else {
    if (mod == MODRM_MOD_MEM_DISP8) {
      disp = *((int8_t*)(ip));
      ip += 1;
    } else if (mod == MODRM_MOD_MEM_DISP32) {
      disp = *((int32_t*)(ip));
      ip += 4;
    }
    result = *regs[IS_REX_R(rex) ? (REX_REG_BIT | rm) : rm] + disp;
  }
  *ipp = ip;
  return (uint64_t*)result;
}

#define FETCH_OPERAND_MODRM_MODRM(modrm, rex, regs, ipreg) \
  fetch_operand_modrm_modrm((modrm), (rex), (regs), &(ipreg))
#define FETCH_OPERAND_IMM_S8(ipreg) (*((int8_t*)(ipreg++)))

static const char *regnames[] = {
  "rax",
  "rcx",
  "rdx",
  "rbx",
  "rsp",
  "rbp",
  "rsi",
  "rdi",
  "r8",
  "r9",
  "r10",
  "r11",
  "r12",
  "r13",
  "r14",
  "r15"
};

int lambchop_vm_main(void *func, uint64_t stacksize, lambchop_logger *logger) {
  uint64_t rip, *regs[16];
  uint8_t opcode, rex, modrm;
  void *stack = malloc(stacksize);
<% REGNAMES.each do |r| -%>
  uint64_t <%= r %>;
<% end -%>
<% REGNAMES.each_with_index do |r, i| -%>
  DEBUG("address <%= r %>: 0x%x\\n", &<%= r %>);
  regs[<%= i %>] = &<%= r %>;
<% end -%>

  assert(stack); // TODO: return error
  rip = (uint64_t)func;
  rbp = ((uint64_t)stack) + (stacksize - sizeof(uint64_t));
  rsp = ((uint64_t)stack) + (stacksize - sizeof(uint64_t));

  while (true) {
<% indent = 4 -%>
<%= gen_rex_fetch('rip', 'rex', indent) -%>
<%= gen_opcode_fetch('rip', 'opcode', indent) -%>
    switch(opcode) {
<% instructions.each do |inst| -%>
<%= gen_instruction(inst, 'rip', indent) -%>
<% end -%>
    default:
      DEBUG("unsupported opcode: 0x%x\\n", opcode);
      assert(false);
    }
  }

  if (stack) {
    free(stack);
  }

  return 0;
}
  EOS

  public
  def generate()
    instructions = [
      Instruction0x50To0x57.new(),
      Instruction0x83.new(),
      Instruction0x89.new(),
      Instruction0x8D.new(),
    ]
    ERB.new(TEMPLATE, 0, '%-').result(binding)
  end
end

puts VMGen.new.generate()
